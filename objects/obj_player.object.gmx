<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_idle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>spr_player_idle</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Initialize variables

//Gravity var
grav = 0.5;

//Vars to control the obj speed
hsp = 0;
hsp_carry = 0;
vsp = 0;
jumpspeed = 10;
movespeed = 6;

hitpushback = 10;
hitpushup = 3;

state = states.idle;

life = 50;

keyboard = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Check life
if(life &lt;= 0){
    room_restart();
}

if(keyboard == true){
    //Get input
    key_right = keyboard_check(vk_right);
    key_left = -keyboard_check(vk_left);
    key_jump = keyboard_check_pressed(ord("S"));
    key_jump_held = keyboard_check(ord("S"));
    key_shot = keyboard_check_pressed(ord("A"));
}
//Movement
move = key_left + key_right;
hsp = move * movespeed;

if(vsp &lt; 10){
    vsp += grav;
}

//Check if the pixel below the player is a wall
if(place_meeting(x,y+1,obj_wall)){
    vsp = key_jump * -jumpspeed;
}



//Animation
//Change the sprite side depending on movement
if(move != 0){
    image_xscale = move;
}

//Change states

switch(state){
    case states.idle:{
        sprite_index = spr_player_idle;
        image_speed = 0.5;
        
        if(key_jump){
            state = states.jump;
            break;
        }
        if(hsp != 0){
            state = states.run;
            break;
        }
        if(key_shot){
            state = states.shot;
            break;
        }
        break;
    }
    case states.jump:{
        if(!key_jump_held){
            vsp = max(vsp, -jumpspeed/3);
        }
        
        if(sprite_index != spr_player_jump){
            sprite_index = spr_player_jump;
            image_speed = 0.5;
        }
        
        if(image_index == 4){
            image_speed = 0;
        }
        
        if(vsp &gt; 0){
            state = states.fall;
            break;
        }
        if(key_shot){
            state = states.jump_shot;
            break;
        }
        break;
    }
    case states.jump_shot:{
    
        if(sprite_index != spr_player_jump_shot){
            sprite_index = spr_player_jump_shot;
            image_speed = 0.5;
        }
        
        if(image_index == 0 || key_shot){
            bullet = instance_create(x+(image_xscale*19),y-5,obj_shot_basic);
            bullet.direction = getSpriteSide(image_xscale);
            key_shot = 0;
        }
        
        if(image_index == 4){
            image_speed = 0;
        }
    
        if(vsp &gt; 0){
            state = states.fall;
            break;
        }
        break;
    }
    case states.run:{
        if(sprite_index != spr_player_run){
            sprite_index = spr_player_run;
            image_speed = 0.5;
        }
    
        if(hsp == 0){
            state = states.idle;
            break;
        }
        if(key_jump){
            state = states.jump;
            break;
        }
        if(key_shot){
            state = states.run_shot;
            break;
        }
        break;
    }
    case states.run_shot:{
        if(sprite_index != spr_player_run_shot){
            sprite_index = spr_player_run_shot;
            image_speed = 0.5;
        }
        
        if(image_index == 0 || key_shot){
            bullet = instance_create(x+(image_xscale*20),y-5,obj_shot_basic);
            bullet.direction = getSpriteSide(image_xscale);
            key_shot = 0;
        }
        
        if(hsp == 0){
            state = states.idle;
            break;
        }
        if(key_jump){
            state = states.jump;
            break;
        }
        break;
    }
    case states.fall:{
        sprite_index = spr_player_fall; 
        image_speed = 0.5;
        
        if(vsp == 0){
            state = states.idle;
            break;
        }
        if(key_shot){
            state = states.fall_shot;
            break;
        }
        break;
    }
    case states.fall_shot:{
        if(sprite_index != spr_player_fall_shot){
            sprite_index = spr_player_fall_shot; 
            image_speed = 0.5;
        }
        
        if(key_shot){
            bullet = instance_create(x+(image_xscale*23),y-7,obj_shot_basic);
            bullet.direction = getSpriteSide(image_xscale);
            key_shot = 0;
        }
        
        if(vsp == 0){
            state = states.idle;
            break;
        }
        break;
    }
    case states.shot:{
        
        if(sprite_index != spr_player_idle_shot){
            sprite_index = spr_player_idle_shot;
            image_speed = 0.5;
        }
        
        if(image_index == 0 || key_shot){
            bullet = instance_create(x+(image_xscale*16),y-1,obj_shot_basic);
            bullet.direction = getSpriteSide(image_xscale);
            key_shot = 0;
        }
        
        if(image_index &gt;= 2 &amp;&amp; !key_shot){
            state = states.idle;
        }
        break;
    }
    case states.hit:{
         if(sprite_index != spr_player_damage){
            sprite_index = spr_player_damage;
            image_speed = 0.7;
            hsp -= hitpushback;
            vsp -= hitpushup;
        }
        
        if(image_index &gt;= 4){
            state = states.idle;
        }
        break;
    }
}

var hsp_final = hsp+hsp_carry;
hsp_carry = 0;

//Check for horizontal colision
if(place_meeting(x+hsp_final,y,obj_wall)){
    while(!place_meeting(x+sign(hsp_final),y,obj_wall)){
        x+= sign(hsp);
    }
    hsp_final = 0;
    hsp = 0;
}

x += hsp_final;

//Check for vertical colision
if(place_meeting(x,y+vsp,obj_wall)){
    while(!place_meeting(x,y+sign(vsp),obj_wall)){
        y+= sign(vsp);
    }
    vsp = 0;
}

y += vsp;

x = min(max(x,0),room_width);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
